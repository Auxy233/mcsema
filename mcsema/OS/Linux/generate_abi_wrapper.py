
import os
import sys
import argparse
import logging
import pprint
from collections import defaultdict
import ccsyspath
import clang.cindex
from clang.cindex import CursorKind, TypeKind
from __builtin__ import True

try:
  tob_path = os.environ['TRAILOFBITS_LIBRARIES']
  cc_path = tob_path + "/llvm/bin/clang"
  clang.cindex.Config.set_library_file(tob_path + "/llvm/lib/libclang.so")
except KeyError:
  cc_path = 'clang'
  pass

syspath = ccsyspath.system_include_paths(cc_path)

SUPPORTED_ARCH = ["x86", "amd64", "sparc32"]

SUPPORTED_LIBRARY_TYPE = ["c", "cpp"]

ARCH_NAME = ""

ABI_LIBRARY_TYPE = "c"

if os.path.exists("debug.log"):
  os.remove("debug.log")

logging.basicConfig(filename="debug.log",level=logging.DEBUG)

cc_pragma = """

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

"""

cc_header = """
  // mcsema ABI library, automatically generated by generate_abi_wrapper.py

//using namespace std;

extern char *gets(char *s); 

__attribute__((used))
void *__mcsema_externs[] = {
"""

FUNCDECL_LIST = defaultdict(list)

FUNCDECL_MANGLED_NAME = set()

LOCAL_HEADERS = []

tu = None

# Check if the file exist at the given paths
def file_exist(all_dirs, file):
  """ Check if file exist.
  """
  for dir in all_dirs:
    path = dir+ '/' +file
    if os.path.exists(path):
      return True
  return os.path.exists(file)

def get_node_info(node, depth=0):
  if depth >= 1:
    children = None
  else:
    children = [get_node_info(c, depth+1) for c in node.get_children()]

  return {
           'kind' : node.kind,
           'usr' : node.get_usr(),
           'spelling' : node.spelling,
           'location' : node.location,
           'display' : node.displayname,
           'extent.start' : node.extent.start,
           'extent.end' : node.extent.end,
           'is_definition' : node.is_definition(),
           'children' : children }

# Process the function types and remove the `__attribute__((...))` identifier
# from the function types
def process_function_types(type_string):
  """ Pre-process the function types for the Funcdecl
  """
  split_string = type_string.split(' ')
  return ' '.join(str for str in split_string if '__attribute__' not in str)

def get_function_pointer(type_string):
  """ convert the function types to the pointer type
  """
  return type_string[0:type_string.find('(')-1] + " (*)" + type_string[type_string.find('('):]

def is_valid_type(type_string):
  if "_Complex" in type_string or 'typeof' in type_string:
    return False
  else:
    return True

def is_blacklisted_func(func_name):
  if 'operator' in func_name:
    return True
  return False

def node_has_name(node):
  return node.spelling != ""
  
def is_node_template(node):
  """ Check the tokens of node to identify if
      the function decl is template.
  """
  for t in tu.get_tokens(extent=node.extent):
    if t.spelling in ["template", "typename", "inline"]:
      return True
  return False
  
def get_node_children(node):
  for child in node.get_children():
    yield child
  
def print_tokens(node):
  logging.debug("\nnode {} {}".format(node.spelling, node.location))
  logging.debug("node {}".format(pprint.pprint(get_node_info(node))))
  for t in tu.get_tokens(extent=node.extent):
    logging.debug("{} {} {}".format(t.kind, t.spelling, t.location))

def visit_func_decl(node):
  """ Visit the function decl node and create a map of
      function name with the mangled name
  """
  #print_tokens(node)
  if node.kind == CursorKind.FUNCTION_DECL:
    func_name = node.spelling
    mangled_name = node.mangled_name
    FUNCDECL_MANGLED_NAME.add(mangled_name)
    
    if is_node_template(node):
      return
  
    if not is_blacklisted_func(func_name):
      func_type = process_function_types(node.type.spelling)
      if is_valid_type(func_type):
        FUNCDECL_LIST[func_name].append([mangled_name, get_function_pointer(func_type), node.location])


  prev_i = None
  for i in node.get_children():
    visit_node(i, prev_i)
    prev_i = i
    
def visit_namespace(node):
  if node.kind == CursorKind.NAMESPACE:
    if node.spelling == "std":
      prev_i = None
      for i in node.get_children():
        visit_node(i, prev_i)
        prev_i = i
    

def visit_node(node, prev_node=None):
  if not node_has_name(node):
    return

  if hasattr(prev_node, "kind"):
    if prev_node.kind == CursorKind.UNEXPOSED_DECL:
      return

  if node.kind == CursorKind.NAMESPACE:
    visit_namespace(node)

  elif node.kind == CursorKind.FUNCTION_DECL:
    visit_func_decl(node)

  else:
    prev_i = None
    for i in node.get_children():
      visit_node(i, prev_i)
      prev_i = i

def write_cc_file(hfile, outfile):
  """ Generate ABI library source for the c headers; 
  """
  basename = os.path.splitext(hfile)[0]

  # generate the abi lib cc file
  with open(outfile, "w") as s:
    s.write(cc_pragma)
    s.write("\n\n")
    s.write("#include \"{}\"".format(hfile))
    s.write("\n\n")
    s.write(cc_header)
    s.write("\n")
    for key in FUNCDECL_LIST.iterkeys():
      type_values = FUNCDECL_LIST[key]
      for type in type_values:
        s.write("  //{}\n".format(repr(type[2])))
        s.write("  (void *)({}),\n".format(key))
    s.write("};\n")
    print "Number of function ", len(FUNCDECL_LIST)
    
def write_cxx_file(hfile, outfile):
  """ Generate ABI library source for the cpp headers; 
  """
  basename = os.path.splitext(hfile)[0]

  # generate the abi lib cc file
  with open(outfile, "w") as s:
    s.write(cc_pragma)
    s.write("\n\n")
    s.write("#include \"{}\"".format(hfile))
    s.write("\n\n")
    s.write("using namespace std;\n")
    s.write(cc_header)
    s.write("\n")
    for key in FUNCDECL_LIST.iterkeys():
      key_values = FUNCDECL_LIST[key]
      for value in key_values:
        s.write("  //{} {}\n".format(repr(value[2]), value[0]))
        # get the mangled name
        s.write("  reinterpret_cast<void *>(({}){}),\n".format(value[1], key))
        #s.write("  (void *)::{},\n".format(key))
    s.write("};\n")
    print "Number of function ", len(FUNCDECL_LIST)

def write_library_file(hfile, outfile):
  global tu
  cc_index = clang.cindex.Index.create()
  libc_type = 'c++' if ABI_LIBRARY_TYPE == "cpp" else 'c'
  if ARCH_NAME.lower() == 'amd64'.lower():
    tu = cc_index.parse(hfile, args=['-x', libc_type, '-m64'])

  elif ARCH_NAME.lower() == 'x86'.lower():
    tu = cc_index.parse(hfile, args=['-x', libc_type, '-m32'])

  else:
    print "Architecture is not supported"
    

  if libc_type is 'c':
    visit_func_decl(tu.cursor)
    write_cc_file(hfile, outfile)
  elif libc_type is 'c++':
    visit_node(tu.cursor)
    write_cxx_file(hfile, outfile)

def write_header_file(file, headers):
  basename = os.path.splitext(file)
  gen_filename = basename[0] + ".h"

  with open(gen_filename, "w") as s:
    s.write("\n")
    s.write("// {}\n".format(cc_path))
    s.write("#ifndef {}_H\n".format(os.path.basename(basename[0]).upper()))
    s.write("#define {}_H\n".format(os.path.basename(basename[0]).upper()))
    s.write("""
#ifndef __has_include
#  define __has_include(x) 1
#endif

#define _GNU_SOURCE 1
#define _REGEX_RE_COMP
#define _BSD_SOURCE 1

""")
    s.write("\n")
    for entry in headers:
      s.write("#if __has_include(<{}>)\n".format(entry))
      s.write("#  include <{}>\n".format(entry))
      s.write("#endif\n")
    for entry in LOCAL_HEADERS:
      s.write("#if __has_include(\"{}\")\n".format(entry))
      s.write("#  include \"{}\"\n".format(entry))
      s.write("#endif\n")
    s.write("\n#endif\n")
    s.flush()
    return gen_filename

def parse_headers(infile, outfile):
  header_files = set()
  with open(infile, "rb") as f:
    headers = f.readlines()
    headers = [x.strip() for x in headers if x.startswith("#include")]
    header_files = [x[x.find("<")+1:x.find(">")] for x in headers if x != ""]
    for entry in headers:
      if len(entry.split("\"")) > 1:
        LOCAL_HEADERS.append(entry.split("\"")[1])
    header_files = [x for x in header_files if file_exist(syspath, x)] 
    hfile = write_header_file(infile, header_files)
    write_library_file(hfile, outfile)

if __name__ == "__main__":
  
  parser = argparse.ArgumentParser()
  
  parser.add_argument(
    '--arch',
    help='Name of the architecture.',
    required=True)
  
  parser.add_argument(
    '--type',
    help='ABI Library types c/c++.',
    required=True)

  parser.add_argument(
    "--input",
    help="The input pre-processed header file",
    required=True)
  
  parser.add_argument(
    "--output",
    help="The output file generated with the script",
    required=True)
  
  args = parser.parse_args(args=sys.argv[1:])
  
  ARCH_NAME = args.arch
  if ARCH_NAME not in SUPPORTED_ARCH:
    logger.debug("Arch {} is not supported!".format(args.arch))
    
  ABI_LIBRARY_TYPE = args.type
  if ABI_LIBRARY_TYPE not in SUPPORTED_LIBRARY_TYPE:
    logger.debug("Library type {} not supported!".format(args.type))

  syspath.append(os.path.dirname(os.path.abspath(args.input)))
  parse_headers(args.input, args.output)